<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaos Coding</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --text-color: #eeeeee;
            --bg-color: #111111;
            --transition-speed: 0.8s;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Inter', sans-serif;
            color: var(--text-color);
        }

        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #text-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2;
            pointer-events: none;
        }

        .slide-text {
            position: absolute;
            font-size: clamp(2rem, 5vw, 4.5rem);
            font-weight: 700;
            text-align: center;
            max-width: 90%;
            opacity: 0;
            transition: opacity var(--transition-speed) ease-in-out;
            pointer-events: none;
            line-height: 1.2;
        }
        
        #links-slide.active {
            pointer-events: auto;
        }

        .slide-text.active {
            opacity: 1;
        }
        
        .slide-text h1 { /* Reset h1 margin inside a slide */
            margin-bottom: 0;
            font-size: inherit;
        }

        #nav-buttons {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            display: flex;
            gap: 1rem;
        }

        .nav-btn {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            padding: 0.75rem 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
        }

        .nav-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .nav-btn:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none;
        }
        
        .links-container {
            margin-top: 1.5rem;
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .link-box {
            display: inline-block;
            font-size: 1em; /* Make it the same size as surrounding text */
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            text-decoration: none;
            color: var(--text-color);
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 0.3rem 0.8rem; /* Adjust padding for inline */
            border-radius: 12px; /* Smaller radius */
            transition: background-color 0.3s;
            vertical-align: middle; /* Align with text */
            margin: 0 0.25rem; /* Add some space around */
        }

        .link-box:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }


    </style>
</head>
<body>
    <canvas id="bg-canvas"></canvas>

    <div id="text-container">
        <div class="slide-text active">
            <h1>Chaos Coding</h1>
            <p style="font-size: 0.3em; font-weight: 400; opacity: 0.8; margin-top: 1rem; text-transform: uppercase; letter-spacing: 0.1em;">
                Building cool sh** when you know nothing
            </p>
        </div>
        <div class="slide-text" style="line-height: 0.9;">
             I have visions
            <br>
            <span style="font-size: 0.5em; font-weight: 400; opacity: 0.8;">(but no hard skills)</span>
        </div>
        <h1 class="slide-text">So I ask stupid questions</h1>
        <h1 class="slide-text">... and get great answers</h1>
        <h1 class="slide-text">I've applied this to literally anything</h1>
        <div class="slide-text" id="links-slide" style="font-size: clamp(1rem, 2.5vw, 2rem); line-height: 1.6;">
             Like a <a href="https://zeliavibecodes.github.io/aura-project/" target="_blank" class="link-box">sensory simulator</a> for my daughter
             <br>
             or interactive <a href="http://go/fandom" target="_blank" class="link-box">insight reports</a>.
        </div>
        <h1 class="slide-text">Rinse and repeat</h1>
        <h1 class="slide-text">Keep on building</h1>
    </div>

    <div id="nav-buttons">
        <button id="prev-btn" class="nav-btn">Previous</button>
        <button id="next-btn" class="nav-btn">Next</button>
        <button id="restart-btn" class="nav-btn hidden">Restart</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script id="vertexShader" type="x-shader/x-vertex">
        // Uniforms passed from JavaScript
        uniform float u_time;
        uniform float u_progress;
        uniform vec2 u_mouse;
        uniform float u_mouse_strength;

        // Attributes for different states
        attribute vec3 a_pos_start;
        attribute vec3 a_pos_end;
        
        // Simplex Noise function by Ashima Arts
        // https://github.com/ashima/webgl-noise
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 = v - i + dot(i, C.xxx) ;
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute( permute( permute(
                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
              + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
              + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857;
            vec3  ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ * ns.x + ns.yyyy;
            vec4 y = y_ * ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }

        void main() {
            // Mix between start and end positions for smooth transitions
            vec3 finalPos = mix(a_pos_start, a_pos_end, u_progress);
            
            // Add organic noise-based movement
            float noiseFreq = 0.5;
            float noiseAmp = 0.15;
            vec3 noisePos = vec3(finalPos.x * noiseFreq, finalPos.y * noiseFreq, u_time * 0.1);
            finalPos.z += snoise(noisePos) * noiseAmp;
            finalPos.x += snoise(noisePos + 10.0) * noiseAmp;

            // Add mouse interaction
            float mouseDist = distance(vec2(finalPos.x, finalPos.y), u_mouse);
            float mouseEffect = smoothstep(0.3, 0.0, mouseDist) * u_mouse_strength;
            finalPos.z += mouseEffect;

            // Projection
            vec4 modelViewPosition = modelViewMatrix * vec4(finalPos, 1.0);
            gl_Position = projectionMatrix * modelViewPosition;
            gl_PointSize = mix(1.0, 3.0, mouseEffect);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        void main() {
            // Fading out particles at the edges
            float dist = distance(gl_PointCoord, vec2(0.5));
            float alpha = 1.0 - smoothstep(0.45, 0.5, dist);
            gl_FragColor = vec4(vec3(0.9), alpha);
        }
    </script>

    <script type="module">
        // --- Core Setup ---
        let scene, camera, renderer, particles, uniforms;
        let currentState = 0;
        let isTransitioning = false;
        const stateCount = 8;
        let textElements = document.querySelectorAll('.slide-text');
        const mouse = new THREE.Vector2(10, 10); // Start offscreen

        // --- Scene Initialization ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 2.5;

            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('bg-canvas'),
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            createParticles();

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize);
            document.getElementById('next-btn').addEventListener('click', () => changeState(currentState + 1));
            document.getElementById('prev-btn').addEventListener('click', () => changeState(currentState - 1));
            document.getElementById('restart-btn').addEventListener('click', () => changeState(0));
            window.addEventListener('mousemove', onMouseMove);

            // Start animation loop
            animate();
            updateNavButtons();
        }

        // --- Particle Creation & Geometry States ---
        function createParticles() {
            const particleCount = 70000;
            const geometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(particleCount * 3);
            const targetAttributes = [];
            for(let i = 0; i < stateCount; i++) {
                targetAttributes.push(new Float32Array(particleCount * 3));
            }

            const R = 1.5; // Radius
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // --- Initial State (Chaos Coding Title) ---
                const spherical = new THREE.Vector3().setFromSphericalCoords(R, Math.acos(1 - 2 * Math.random()), Math.random() * Math.PI * 2);
                positions[i3] = spherical.x;
                positions[i3 + 1] = spherical.y;
                positions[i3 + 2] = spherical.z;

                // --- State 1: Visions (Scattered) ---
                targetAttributes[1][i3] = (Math.random() - 0.5) * 8;
                targetAttributes[1][i3 + 1] = (Math.random() - 0.5) * 8;
                targetAttributes[1][i3 + 2] = (Math.random() - 0.5) * 4 - 2;

                // --- State 2: Questions (Mouse Interactive) -> same as visions
                targetAttributes[2][i3] = targetAttributes[1][i3];
                targetAttributes[2][i3 + 1] = targetAttributes[1][i3+1];
                targetAttributes[2][i3 + 2] = targetAttributes[1][i3+2];

                // --- State 3: Answers (Geometric Form - Sphere) ---
                const answerSpherical = new THREE.Vector3().setFromSphericalCoords(R * 0.8, Math.acos(1 - 2 * Math.random()), Math.random() * Math.PI * 2);
                targetAttributes[3][i3] = answerSpherical.x;
                targetAttributes[3][i3+1] = answerSpherical.y;
                targetAttributes[3][i3+2] = answerSpherical.z;
                
                // --- State 4: Apply (Frame) ---
                const edge = Math.floor(Math.random() * 4);
                const aspect = window.innerWidth / window.innerHeight;
                let x, y;
                if (edge === 0) { x = -2.5*aspect; y = (Math.random() - 0.5) * 5; }
                else if (edge === 1) { x = 2.5*aspect; y = (Math.random() - 0.5) * 5; }
                else if (edge === 2) { y = -2.5; x = (Math.random() - 0.5) * 5 * aspect; }
                else { y = 2.5; x = (Math.random() - 0.5) * 5 * aspect; }
                targetAttributes[4][i3] = x;
                targetAttributes[4][i3+1] = y;
                targetAttributes[4][i3+2] = (Math.random() - 0.5) * 0.5;

                // --- State 5: Links (Gentle Cloud) ---
                targetAttributes[5][i3] = (Math.random() - 0.5) * 5;
                targetAttributes[5][i3 + 1] = (Math.random() - 0.5) * 5;
                targetAttributes[5][i3 + 2] = (Math.random() - 0.5) * 3;

                // --- State 6: Rinse and Repeat (Vortex) ---
                const r = Math.random() * R * 1.2;
                const angle = Math.random() * Math.PI * 10;
                targetAttributes[6][i3] = r * Math.cos(angle);
                targetAttributes[6][i3 + 1] = r * Math.sin(angle);
                targetAttributes[6][i3 + 2] = (Math.random() - 0.5 - angle * 0.05) * 0.5;

                // --- State 7: Build (Complex Structure) ---
                const cubeSize = 0.5;
                const sphereInCube = new THREE.Vector3().setFromSphericalCoords(R * 0.15, Math.acos(1 - 2 * Math.random()), Math.random() * Math.PI * 2);
                const cubeOffset = new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)).multiplyScalar(cubeSize * 2);
                targetAttributes[7][i3] = sphereInCube.x + cubeOffset.x;
                targetAttributes[7][i3+1] = sphereInCube.y + cubeOffset.y;
                targetAttributes[7][i3+2] = sphereInCube.z + cubeOffset.z;

                // State 0 (Title) is the same as the initial positions
                targetAttributes[0][i3] = positions[i3];
                targetAttributes[0][i3+1] = positions[i3+1];
                targetAttributes[0][i3+2] = positions[i3+2];
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('a_pos_start', new THREE.BufferAttribute(positions.slice(), 3));
            geometry.setAttribute('a_pos_end', new THREE.BufferAttribute(targetAttributes[0].slice(), 3));
            geometry.userData.targetAttributes = targetAttributes;

            uniforms = {
                u_time: { value: 0.0 },
                u_progress: { value: 0.0 },
                u_mouse: { value: mouse },
                u_mouse_strength: { value: 0.0 }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true,
                depthTest: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updateNavButtons() {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const restartBtn = document.getElementById('restart-btn');

            // Default all to hidden
            prevBtn.classList.add('hidden');
            nextBtn.classList.add('hidden');
            restartBtn.classList.add('hidden');

            if (currentState === 0) {
                // First slide
                nextBtn.classList.remove('hidden');
            } else if (currentState === stateCount - 1) {
                // Last slide
                restartBtn.classList.remove('hidden');
            } else {
                // In-between slides
                prevBtn.classList.remove('hidden');
                nextBtn.classList.remove('hidden');
            }
        }
        
        function changeState(newState) {
            if (isTransitioning && newState !== 0) return; // Allow restart anytime
            
            newState = Math.max(0, Math.min(stateCount - 1, newState));
            
            if (newState === currentState && currentState !== stateCount -1) return;

            isTransitioning = true;
            const oldState = currentState;
            currentState = newState;
            
            updateNavButtons();

            textElements[oldState].classList.remove('active');
            textElements[currentState].classList.add('active');
            
            const geometry = particles.geometry;
            const targetAttributes = geometry.userData.targetAttributes;

            const startAttribute = geometry.getAttribute('a_pos_start');
            const endAttribute = geometry.getAttribute('a_pos_end');
            const currentPosition = new Float32Array(startAttribute.count * 3);
            for(let i=0; i<startAttribute.count; i++) {
                const i3 = i * 3;
                const x = THREE.MathUtils.lerp(startAttribute.array[i3], endAttribute.array[i3], uniforms.u_progress.value);
                const y = THREE.MathUtils.lerp(startAttribute.array[i3+1], endAttribute.array[i3+1], uniforms.u_progress.value);
                const z = THREE.MathUtils.lerp(startAttribute.array[i3+2], endAttribute.array[i3+2], uniforms.u_progress.value);
                currentPosition[i3] = x;
                currentPosition[i3+1] = y;
                currentPosition[i3+2] = z;
            }
            geometry.setAttribute('a_pos_start', new THREE.BufferAttribute(currentPosition, 3));
            geometry.setAttribute('a_pos_end', new THREE.BufferAttribute(targetAttributes[currentState], 3));
            uniforms.u_progress.value = 0.0;
            
            if (currentState === 2) {
                uniforms.u_mouse_strength.value = 1.5;
            } else {
                uniforms.u_mouse_strength.value = 0.3;
            }

            let progress = { value: 0 };
            const transitionDuration = 1500;
            const startTime = performance.now();

            function animateTransition() {
                const elapsedTime = performance.now() - startTime;
                let t = Math.min(1, elapsedTime / transitionDuration);
                t = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                uniforms.u_progress.value = t;

                if (t < 1) {
                    requestAnimationFrame(animateTransition);
                } else {
                    isTransitioning = false;
                }
            }
            animateTransition();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            uniforms.u_mouse.value.x = pos.x;
            uniforms.u_mouse.value.y = pos.y;
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            uniforms.u_time.value = clock.getElapsedTime();
            
            if (currentState === 7 && !isTransitioning) {
                particles.rotation.y += 0.001;
            } else {
                 particles.rotation.y = 0;
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>

